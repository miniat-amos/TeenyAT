#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdint>
#include <cstddef>
#include <iomanip>
#include <cctype>
#include <cstdlib>
#include <cstdio>
#include <filesystem>


using namespace std;


const char* HEADER = "bin_assets.h";
const char* SOURCE = "bin_assets.cpp";
const string ARRAY_PREFIX = "bin_asset_";
const size_t BYTES_PER_LINE = 10;


/*
 * Replace non-alphanumeric-underscore character with underscores
 */
string clean_filename(const string& filename) {
    string clean_name;

    std::filesystem::path p(filename);
    string file_only_name = p.filename().string();

    for(char c : file_only_name) {
        if(isalnum((unsigned char)(c)) || c == '_') {
            clean_name += c;
        } else {
            clean_name += '_';
        }
    }

    // name can't start with a digit
    if(!clean_name.empty() && isdigit((unsigned char)(clean_name[0]))) {
        clean_name.insert(0, "_");
    }

    return clean_name;
}


/*
 * delete the header and source files and exit with error
 */
void leave_no_trace(const string& error_message, ofstream& header, ofstream& source) {
    cerr << "Error: " << error_message << endl;

    if(header.is_open()) {
        header.close();
    }
    if(source.is_open()) {
        source.close();
    }

    remove(HEADER);
    remove(SOURCE);

    exit(EXIT_FAILURE);
}


int main(int argc, char* argv[]) {
    if(argc < 2) {
        cerr << "Usage: " << argv[0] << " <file1> [ <file2> ... ]" << endl;
        cerr << "Generates " << HEADER << " and " << SOURCE << " containing binary assets." << endl;
        return EXIT_FAILURE;
    }

    ofstream header;
    ofstream source;

    header.open(HEADER);
    if(!header) {
        cerr << "Error: Could not open header file '" << HEADER << "'"<< endl;
        remove(HEADER);
        return EXIT_FAILURE;
    }

    source.open(SOURCE);
    if(!source) {
        cerr << "Error: Could not open source file '" << SOURCE << "'" << endl;
        header.close();
        remove(HEADER);
        remove(SOURCE);
        return EXIT_FAILURE;
    }

    header << "/* Generated by " << __FILE__ << " - DO NOT EDIT */" << endl;
    header << "#ifndef __BIN_ASSETS_H__" << endl;
    header << "#define __BIN_ASSETS_H__" << endl << endl;
    header << "#include <cstdint>" << endl;
    header << "#include <cstddef>" << endl << endl;
    if(!header) {
        leave_no_trace("Failed to write header boilerplate.", header, source);
    }

    source << "/* Generated by " << __FILE__ << " - DO NOT EDIT */" << endl;
    source << "#include \"" << HEADER << "\"" << endl << endl;
    if(!source) {
        leave_no_trace("Failed to write source boilerplate.", header, source);
    }

    /*
     * Process each command line file argument
     */
    for (int i = 1; i < argc; ++i) {
        string path = argv[i];

        string base_identifier = clean_filename(path);
        string array_name = ARRAY_PREFIX + base_identifier;
        string size_name = array_name + "_len";

        cout << "Processing '" << path << "' -> " << array_name << "..." << endl;

        ifstream input_file(path, ios::binary | ios::ate);
        if(!input_file) {
            leave_no_trace("Could not open input file '" + path + "'.", header, source);
        }

        streamsize file_size = input_file.tellg();
        size_t size = (size_t)file_size;

        input_file.seekg(0, ios::beg);
        vector<uint8_t> buffer(size);
        if (size > 0) {
            if (!input_file.read(reinterpret_cast<char*>(buffer.data()), file_size)) {
                input_file.close();
                leave_no_trace("Error reading data from input file '" + path + "'.", header, source);
            }
        }
        else {
            input_file.close();
            leave_no_trace("Error reading zero-sized input file '" + path + "'.", header, source);
        }

        input_file.close();


        header << "/* Asset: " << path << " */" << endl;
        header << "extern const uint8_t " << array_name << "[];" << endl;
        header << "extern const size_t " << size_name << ";" << endl << endl;
        if(!header) {
            leave_no_trace("Failed to write to header file for '" + path + "'.", header, source);
        }

        source << "/* Asset: " << path << " */" << endl;
        source << "extern const size_t " << size_name << " = " << buffer.size() << ";" << endl;
        source << "extern const uint8_t " << array_name << "[" << size_name << "] = {" << endl;
        if(!source) {
            leave_no_trace("Failed to write size to source file for '" + path + "'.", header, source);
        }

        if(!buffer.empty()) {
            source << "    ";
            for(size_t j = 0; j < buffer.size(); ++j) {
                source << "0x" << hex << setw(2) << setfill('0') << (int)buffer[j];

                if(j < buffer.size() - 1) {
                    /* need comma if not the last element */
                    source << ",";
                    if((j + 1) % BYTES_PER_LINE == 0) {
                        source << endl << "    "; // newline/indent
                    } else {
                        source << " ";
                    }
                }
            }
            source << endl; // Newline after last byte
        }
        source << "};" << endl << endl;
        if(!source) {
            leave_no_trace("Failed to write data to source file for '" + path + "'.", header, source);
        }
        source << dec;
    }

    header << "#endif /* __BIN_ASSETS_H__ */" << endl;
    if(!header) {
        leave_no_trace("Failed to write closing guard to header file.", header, source);
    }

    header.close();
    source.close();

    cout << "Successfully generated " << HEADER << " and " << SOURCE << endl;

    return EXIT_SUCCESS;
}
